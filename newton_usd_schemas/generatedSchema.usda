#usda 1.0
(
)

class NewtonSceneAPI "NewtonSceneAPI" (
    doc = "NewtonSceneAPI applies on top of a PhysicsScene Prim, providing attributes to control a Newton Solver."
)
{
    uniform int newton:maxSolverIterations = -1 (
        doc = """Maximum number of iterations of the physics solver.

        If set to -1, each solver is free to choose an appropriate default.

        Range: [-1, inf)
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                int minimum = -1
            }
        }
    )

    uniform int newton:timeStepsPerSecond = 1000 (
        doc = """Simulation time step frequency in Hz.

        Range: [1, inf)
        Units: hertz"""
        limits = {
            dictionary hard = {
                int minimum = 1
            }
        }
    )

    bool newton:gravityEnabled = true (
        doc = """Whether gravity should be enabled or disabled in the simulation.

        This is intentionally separated from the gravity direction and magnitude
        to allow temporary disabling of gravity without modifying & caching values.
        """
    )
}

class "NewtonXpbdSceneAPI" (
    apiSchemas = ["NewtonSceneAPI"]
    doc = "Provides Newton's XPBD (eXtended Position-Based Dynamics) solver configuration."
)
{
    uniform float newton:xpbd:softBodyRelaxation = 0.9 (
        doc = """Relaxation multiplier for tetrahedral FEM constraint corrections.

        Scales the computed position correction for tetrahedral soft body constraints.
        Lower values improve stability but require more iterations for convergence.

        Range: [0, 1]
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
                float maximum = 1
            }
        }
    )

    uniform float newton:xpbd:softContactRelaxation = 0.9 (
        doc = """Relaxation multiplier for soft contact constraint corrections.

        Scales the computed position correction for particle-particle and particle-shape
        contacts. Lower values improve stability but require more iterations for convergence.

        Range: [0, 1]
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
                float maximum = 1
            }
        }
    )

    uniform float newton:xpbd:jointLinearRelaxation = 0.7 (
        doc = """Relaxation multiplier for joint linear constraint corrections.

        Scales the computed position correction for joint linear (positional) constraints.
        Lower values improve stability for complex kinematic chains but slow convergence.

        Range: [0, 1]
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
                float maximum = 1
            }
        }
    )

    uniform float newton:xpbd:jointAngularRelaxation = 0.4 (
        doc = """Relaxation multiplier for joint angular constraint corrections.

        Scales the computed rotation correction for joint angular (rotational) constraints.
        Lower values improve stability but slow convergence.

        Range: [0, 1]
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
                float maximum = 1
            }
        }
    )

    uniform float newton:xpbd:jointLinearCompliance = 0.0 (
        doc = """Compliance for joint linear constraints.

        Inverse stiffness for joint linear constraints. Added to denominator in constraint
        solver. Zero creates rigid constraints. Higher values create softer, springy joints.

        Range: [0, inf)
        Units: second * second / mass"""
        limits = {
            dictionary hard = {
                float minimum = 0
            }
        }
    )

    uniform float newton:xpbd:jointAngularCompliance = 0.0 (
        doc = """Compliance for joint angular constraints.

        Inverse stiffness for joint angular constraints. Added to denominator in constraint
        solver. Zero creates rigid constraints. Higher values create softer, springy joints.

        Range: [0, inf)
        Units: degrees * second * second / (mass * distance * distance)"""
        limits = {
            dictionary hard = {
                float minimum = 0
            }
        }
    )

    uniform float newton:xpbd:rigidContactRelaxation = 0.8 (
        doc = """Relaxation multiplier for rigid body contact constraint corrections.

        Scales the computed correction for rigid body contacts including normal, friction,
        torsional friction, and rolling friction. Lower values improve stability for
        stacking but require more iterations.

        Range: [0, 1]
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
                float maximum = 1
            }
        }
    )

    uniform bool newton:xpbd:rigidContactConWeighting = true (
        doc = """Enable contact constraint weighting for rigid bodies.

        When enabled, tracks the number of contacts per body and uses this information
        to distribute contact corrections more evenly across multiple simultaneous contacts."""
    )

    uniform float newton:xpbd:angularDamping = 0.0 (
        doc = """Angular velocity damping coefficient.

        Applied during rigid body integration as velocity *= (1 - damping * dt). Higher
        values cause rotational motion to decay faster.

        Range: [0, inf)
        Units: 1 / seconds"""
        limits = {
            dictionary hard = {
                float minimum = 0
            }
        }
    )

    uniform bool newton:xpbd:restitutionEnabled = false (
        doc = """Whether restitution is enabled for contacts.

        When enabled, applies velocity corrections after constraint solving to simulate
        elastic collisions. Restitution coefficients are read from material properties."""
    )
}

class "NewtonKaminoSceneAPI" (
    apiSchemas = ["NewtonSceneAPI"]
    doc = "Provides Newton's Kamino solver configuration."
)
{
    uniform float newton:kamino:padmm:primalTolerance = 1e-6 (
        doc = """The tolerance on the total PADMM primal residual `r_primal`.

        The primal residual `r_primal` measures the convergence of the PADMM primal variables,
        w.r.t the consensus between the primal and slack variables. This reflects how well the
        solution satisfies the inequality constraints (joint-limits, contacts). Lower values
        require more iterations for higher accuracy.

        Range: [1e-10, inf)
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 1e-10
            }
        }

    )

    uniform float newton:kamino:padmm:dualTolerance = 1e-6 (
        doc = """The tolerance on the total PADMM dual residual `r_dual`.

        The dual residual `r_dual` measures the convergence of the PADMM dual variables,
        and reflects the total violation over the set of constraints (joints, joint-limits,
        contacts). Lower values require more iterations for higher accuracy.

        Range: [1e-10, inf)
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 1e-10
            }
        }
    )

    uniform float newton:kamino:padmm:complementarityTolerance = 1e-6 (
        doc = """The tolerance on the total PADMM complementarity residual `r_compl`.

        The complementarity residual `r_compl` measures how well the solution satisfies the
        complementarity conditions associated with inequality constraints (joint-limits,
        contacts). Lower values require more iterations for higher accuracy.

        Range: [1e-10, inf)
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 1e-10
            }
        }
    )

    uniform token newton:kamino:padmm:warmstarting = "containers" (
        allowedTokens = ["none", "internal", "containers"]
        doc = """The warmstarting mode used for the PADMM constraint solver.

        Options:
        - "none": No warmstarting is performed.
        - "internal": Warmstart using the PADMM internal solver state from the previous time step.
        - "containers": Warmstart using cached per-constraint impulses and velocities from the previous time step.

        Default: "containers"
        """
    )

    uniform bool newton:kamino:padmm:useAcceleration = true (
        doc = """Whether to use Nesterov acceleration in the PADMM constraint solver.

        When enabled, Nesterov acceleration is applied to the PADMM
        iterations to potentially improve the rate of convergence.
        """
    )

    uniform bool newton:kamino:constraints:usePreconditioning = true (
        doc = """Whether to use problem preconditioning in the constraint forward dynamics.

        When enabled, the forward dynamics problem is scaled to improve numerical conditioning, which
        can lead to solver robustness for very ill-conditioned systems. It may however slow down
        convergence for well-conditioned systems.
        """
    )

    uniform float newton:kamino:constraints:alpha = 0.01 (
        doc = """Global default Baumgarte stabilization parameter for bilateral joint constraints.

        This parameter controls the amount of configuration-level error correction applied to bilateral
        joint constraints (e.g. hinge, ball-and-socket). Higher values increase stiffness and reduce
        positional drift, but may lead to instability if set too high.

        Range: [0.0, 1.0]
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
                float maximum = 1
            }
        }
    )

    uniform float newton:kamino:constraints:beta = 0.01 (
        doc = """Global default Baumgarte stabilization parameter for unilateral joint-limit constraints.

        This parameter controls the amount of configuration-level error correction applied to unilateral
        joint-limit constraints. Higher values increase stiffness and reduce positional drift, but may
        lead to instability if set too high.

        Range: [0.0, 1.0]
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
                float maximum = 1
            }
        }
    )

    uniform float newton:kamino:constraints:gamma = 0.01 (
        doc = """Global default Baumgarte stabilization parameter for unilateral contact constraints.

        This parameter controls the amount of configuration-level error correction applied to unilateral
        contact constraints. Higher values increase stiffness and reduce positional drift, but may
        lead to instability if set too high.

        Range: [0.0, 1.0]
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
                float maximum = 1
            }
        }
    )

    uniform token newton:kamino:jointCorrection = "twopi" (
        allowedTokens = ["none", "twopi", "continuous"]
        doc = """The rotation roll-over correction mode to use for rotational joint DoFs.

        Options:
        - "none": No joint coordinate correction is applied. Rotational joint coordinates are computed to lie within ``[-pi, pi]``.
        - "twopi": Rotational joint coordinates are computed to always lie within ``[-2*pi, 2*pi]``.
        - "continuous": Rotational joint coordinates are continuously accumulated and thus unbounded.
          This means that joint coordinates can increase/decrease indefinitely over time,
          but are limited to numerical precision limits (i.e. ``[-FLOAT32_MAX, FLOAT32_MAX]``).

        Default: "twopi"
        """
    )
}

class NewtonArticulationRootAPI "NewtonArticulationRootAPI" (
    apiSchemas = ["PhysicsArticulationRootAPI"]
    doc = """NewtonArticulationRootAPI extends the `PhysicsArticulationRootAPI` with additional attributes for Newton.

    By applying this schema, the prim also inherits the `PhysicsArticulationRootAPI` schema."""
)
{
    bool newton:selfCollisionEnabled = true (
        doc = """Whether self collisions should be enabled or disabled for the entire articulation.

        When disabled, this is equivalent to applying `PhysicsFilteredPairsAPI` relationships between all bodies in the articulation."""
    )
}

class NewtonCollisionAPI "NewtonCollisionAPI" (
    apiSchemas = ["PhysicsCollisionAPI"]
    doc = """NewtonCollisionAPI applies on top of a Gprim, providing extra collision attributes for Newton.

    By applying this schema, the prim also inherits the `PhysicsCollisionAPI` schema."""
)
{
    float newton:contactMargin = 0 (
        doc = """Outward offset/inflation of the shape's surface for collision detection.

        Extends/inflates the effective collision surface outward by this amount. When two shapes collide,
        their contact margins are summed (`margin_a + margin_b`) to determine the total separation/penetration.
        
        `newton:contactMargin` is essential for thin shells and cloth to improve simulation stability and reduce
        self-intersections.

        Range: [0, inf)
        Units: distance"""
        limits = {
            dictionary soft = {
                float minimum = 0
            }
        }
    )
    float newton:contactGap = -inf (
        doc = """Additional contact detection gap.

        AABBs are expanded by this value and potential contact points get added into the solver
        once their separation is smaller than the contact gap sum (`margin_a + margin_b + gap_a + gap_b`).

        Increasing `newton:contactGap` helps avoid tunneling by detecting contacts earlier.

        If `newton:contactGap` is set to `-inf`, Newton's builder default should be used instead.

        Range: [0, inf)
        Units: distance"""
        limits = {
            dictionary hard = {
                float minimum = 0
            }
        }
    )
}

class NewtonMeshCollisionAPI "NewtonMeshCollisionAPI" (
    apiSchemas = ["NewtonCollisionAPI", "PhysicsMeshCollisionAPI"]
    doc = """NewtonMeshCollisionAPI applies on top of a Mesh, providing extra mesh collision attributes for Newton.

    By applying this schema, the prim also inherits the `PhysicsCollisionAPI`, `NewtonCollisionAPI` and `PhysicsMeshCollisionAPI` schemas."""
)
{
    uniform int newton:maxHullVertices = -1 (
        doc = """Maximum number of vertices in the resulting convex hull approximation.

        This value is only relevant when `physics:approximation = "convexHull"`.

        If `newton:maxHullVertices` is set to -1, the hull computation should use as many vertices as necessary to produce a perfect convex hull.

        Range: [-1, inf)
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                int minimum = -1
            }
        }
    )
}

class NewtonMaterialAPI "NewtonMaterialAPI" (
    apiSchemas = ["PhysicsMaterialAPI"]
    doc = """NewtonMaterialAPI applies on top of a Material, providing extra physical material attributes for Newton.

    By applying this schema, the prim also inherits the `PhysicsMaterialAPI` schema."""
)
{
    float newton:torsionalFriction = 0.25 (
        doc = """Torsional friction coefficient (resistance to spinning at a contact point).

        Range: [0, inf)
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
            }
        }
    )

    float newton:rollingFriction = 0.0005 (
        doc = """Rolling friction coefficient (resistance to rolling motion).

        Range: [0, inf)
        Units: dimensionless"""
        limits = {
            dictionary hard = {
                float minimum = 0
            }
        }
    )
}

class NewtonMimicAPI "NewtonMimicAPI" (
    doc = """NewtonMimicAPI applies on top of a PhysicsJoint, adding additional constraints to mimic the DOFs of another joint.

    A mimic constraint enforces that `joint0 = coef0 + coef1 * joint1` for the joint DOFs,
    where `joint0` is this joint (the follower) and `joint1` (the leader) is specified via the `newton:mimicJoint` relationship.

    The behavior on multi-DOF joints is undefined. The mimic constraint will be applied to each DOF independently,
    but as the coefficients are shared across all DOFs, the units for translational and rotational DOFs will be mixed.
    Therefore, it is recommended to only use this API on single-DOF joints.
    """
)
{
    bool newton:mimicEnabled = true (
        doc = """Whether the mimic constraint is active.

        When disabled, the follower joint moves independently, as though the mimic constraint was not applied."""
    )

    rel newton:mimicJoint (
        doc = "Joint that will be mimicked."
    )

    float newton:mimicCoef0 = 0.0 (
        doc = """Offset added after scaling the leader joint's position/angle.

        In the mimic equation which constrains the joint DOFs, `joint0 = coef0 + coef1 * joint1`,
        this is the constant offset term.

        Range: (-inf, inf)
        Units: distance or degrees (matches the joint type for single-DOF joints)"""
    )

    float newton:mimicCoef1 = 1.0 (
        doc = """Scale factor applied to the leader joint's position/angle.

        In the mimic equation which constrains the joint DOFs, `joint0 = coef0 + coef1 * joint1`,
        this is the linear coefficient.

        A value of 1.0 means the follower tracks the leader exactly (plus offset from `newton:mimicCoef0`),
        while negative values reverse the direction.

        Range: (-inf, inf)
        Units: dimensionless"""
    )
}