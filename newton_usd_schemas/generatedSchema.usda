#usda 1.0
(
)

class NewtonSceneAPI "NewtonSceneAPI" (
    doc = "NewtonSceneAPI applies on top of a PhysicsScene Prim, providing attributes to control a Newton Solver."
)
{
    uniform int newton:maxSolverIterations = -1 (
        doc = """Maximum number of iterations of the physics solver.

        If set to -1, each solver is free to choose an appropriate default."""
    )

    uniform int newton:timeStepsPerSecond = 1000 (
        doc = "Simulation time step frequency in Hz"
    )

    bool newton:gravityEnabled = true (
        doc = """Whether gravity should be enabled or disabled in the simulation.

        This is intentionally separated from the gravity direction and magnitude
        to allow temporary disabling of gravity without modifying & caching values.
        """
    )
}

class "NewtonXpbdSceneAPI" (
    apiSchemas = ["NewtonSceneAPI"]
    doc = "Provides Newton's XPBD (eXtended Position-Based Dynamics) solver configuration."
)
{
    uniform float newton:xpbd:softBodyRelaxation = 0.9 (
        doc = """Relaxation multiplier for tetrahedral FEM constraint corrections.
        
        Scales the computed position correction for tetrahedral soft body constraints.
        Lower values improve stability but require more iterations for convergence.
        
        Range: [0, 1]
        Units: dimensionless"""
    )

    uniform float newton:xpbd:softContactRelaxation = 0.9 (
        doc = """Relaxation multiplier for soft contact constraint corrections.
        
        Scales the computed position correction for particle-particle and particle-shape
        contacts. Lower values improve stability but require more iterations for convergence.
        
        Range: [0, 1]
        Units: dimensionless"""
    )

    uniform float newton:xpbd:jointLinearRelaxation = 0.7 (
        doc = """Relaxation multiplier for joint linear constraint corrections.
        
        Scales the computed position correction for joint linear (positional) constraints.
        Lower values improve stability for complex kinematic chains but slow convergence.
        
        Range: [0, 1]
        Units: dimensionless"""
    )

    uniform float newton:xpbd:jointAngularRelaxation = 0.4 (
        doc = """Relaxation multiplier for joint angular constraint corrections.
        
        Scales the computed rotation correction for joint angular (rotational) constraints.
        Lower values improve stability but slow convergence.
        
        Range: [0, 1]
        Units: dimensionless"""
    )

    uniform float newton:xpbd:jointLinearCompliance = 0.0 (
        doc = """Compliance for joint linear constraints.
        
        Inverse stiffness for joint linear constraints. Added to denominator in constraint
        solver. Zero creates rigid constraints. Higher values create softer, springy joints.
        
        Range: [0, inf)
        Units: second * second / mass"""
    )

    uniform float newton:xpbd:jointAngularCompliance = 0.0 (
        doc = """Compliance for joint angular constraints.
        
        Inverse stiffness for joint angular constraints. Added to denominator in constraint
        solver. Zero creates rigid constraints. Higher values create softer, springy joints.
        
        Range: [0, inf)
        Units: degrees * second * second / (mass * distance * distance)"""
    )

    uniform float newton:xpbd:rigidContactRelaxation = 0.8 (
        doc = """Relaxation multiplier for rigid body contact constraint corrections.
        
        Scales the computed correction for rigid body contacts including normal, friction,
        torsional friction, and rolling friction. Lower values improve stability for
        stacking but require more iterations.
        
        Range: [0, 1]
        Units: dimensionless"""
    )

    uniform bool newton:xpbd:rigidContactConWeighting = true (
        doc = """Enable contact constraint weighting for rigid bodies.
        
        When enabled, tracks the number of contacts per body and uses this information
        to distribute contact corrections more evenly across multiple simultaneous contacts."""
    )

    uniform float newton:xpbd:angularDamping = 0.0 (
        doc = """Angular velocity damping coefficient.
        
        Applied during rigid body integration as velocity *= (1 - damping * dt). Higher
        values cause rotational motion to decay faster.
        
        Range: [0, inf)
        Units: 1 / seconds"""
    )

    uniform bool newton:xpbd:restitutionEnabled = false (
        doc = """Whether restitution is enabled for contacts.
        
        When enabled, applies velocity corrections after constraint solving to simulate
        elastic collisions. Restitution coefficients are read from material properties."""
    )
}

class NewtonCollisionAPI "NewtonCollisionAPI" (
    apiSchemas = ["PhysicsCollisionAPI"]
    doc = """NewtonCollisionAPI applies on top of a Gprim, providing extra collision attributes for Newton.

    By applying this schema, the prim also inherits the `PhysicsCollisionAPI` schema."""
)
{
    float newton:contactMargin = -inf (
        doc = """Distance threshold below which contacts are detected.

        If `newton:contactMargin` is set to -inf, the contact margin will be calculated automatically based on the size of the object."""
    )
}

class NewtonMeshCollisionAPI "NewtonMeshCollisionAPI" (
    apiSchemas = ["NewtonCollisionAPI", "PhysicsMeshCollisionAPI"]
    doc = """NewtonMeshCollisionAPI applies on top of a Mesh, providing extra mesh collision attributes for Newton.

    By applying this schema, the prim also inherits the `PhysicsCollisionAPI`, `NewtonCollisionAPI` and `PhysicsMeshCollisionAPI` schemas."""
)
{
    uniform int newton:maxHullVertices = -1 (
        doc = """Maximum number of vertices in the resulting convex hull approximation.

        This value is only relevant when `physics:approximation = "convexHull"`.

        If `newton:maxHullVertices` is set to -1, the hull computation should use as many vertices as necessary to produce a perfect convex hull."""
    )
}

class NewtonMaterialAPI "NewtonMaterialAPI" (
    apiSchemas = ["PhysicsMaterialAPI"]
    doc = """NewtonMaterialAPI applies on top of a Material, providing extra physical material attributes for Newton.

    By applying this schema, the prim also inherits the `PhysicsMaterialAPI` schema."""
)
{
    float newton:torsionalFriction = 0 (
        doc = "Torsional friction coefficient (resistance to spinning at a contact point)."
    )

    float newton:rollingFriction = 0 (
        doc = "Rolling friction coefficient (resistance to rolling motion)."
    )
}
